---
title: "Fetal Kidney Data Analysis Functions"
---

# RUN THIS BEFORE EVERYTHING
```{r, message=FALSE, warning=FALSE}
library(Seurat)
library(dplyr)
library(ggplot2)
library(monocle)
library(igraph)
library(pheatmap)
library(WGCNA)
library(mclust)

# Cell Cycle Genes
cc.genes <- read.table("info/ccgenes.txt", header=F, stringsAsFactors=F)$V1

# Kidney Marker Genes
marker.genes <- read.table("info/markergenes.txt",header=F, stringsAsFactors = F)$V1

# Ensembl to Symbol (HG19)
genes.ensembl <- read.table("info/genes_ensembl.txt", header=F,row.names=2)

# ligand receptorslib
rl <- read.table("info/receptor_ligands.txt")
# 
# Prints to stderr
cerr <- function (s) {
  write(s, stderr())
}

gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}

setwd("/media/sena/d/USC/Smithlab/Projects/Private/McMahon/Fetal_Organoid_Match")
```

#################################################################################################
# SEURAT
#################################################################################################

## Helper functions to plot and save many figures
```{r}
# Saves all feature plots
FeatureAll <- function(srt, marker.genes, out.dir) {
  for(i in marker.genes) {
    if(i %in% rownames(srt@scale.data)){
      print(FeaturePlot(srt, i, cols.use = c("darkblue", "red"), no.axes=T, no.legend = F))
      dev.print(pdf, file = sprintf(paste0(out.dir, "/%s.pdf"), i), width = 16, height = 9)
    }
  }
}

FeatureTopDiff <- function(srt, out.dir, n = 10) {
  mark <- srt@cluster.markers
  mark %>% group_by(cluster) %>% top_n(n, avg_diff) -> topn
  for(i in unique(topn$cluster)) {
      genes <- topn[topn$cluster == i,]$gene
      FeatureAll(srt, genes, sprintf(paste0(out.dir, "/cluster_%s"),i))
  }
}

# Saves all violin plots
ViolinAll <- function(srt, marker.genes, out.dir) {
  for(i in marker.genes) {
    if(i %in% rownames(srt@scale.data)){
      print(VlnPlot(srt, i))
      dev.print(pdf, file = sprintf(paste0(out.dir, "/%s.pdf"), i), width = 16, height = 9)
    }
  }
}

# Save all PCs
PCAll <- function(srt, out.path) {
  print(out.path)
  for(i in srt@pcs.to.keep) {
    print(PCHeatmap(srt, pc.use = i, cells.use = 100, do.balanced = T, label.columns = F))
    dev.print(pdf, file = sprintf(paste0(out.path, "/PC%s.pdf"), i), width = 9, height = 15)
  }
  
  # Saves jackstraw as well
  print(JackStrawPlot(srt, PCs = 1:50))
  dev.print(pdf, file = paste0(out.path, "/JackStraw.pdf"), width = 9, height = 25)
}
```

## Heatmap of top DE genes based on average difference
```{r}
diff.heatmap <- function(srt, n = 20, p.cutoff = 1e-5) {
  mark <- srt@cluster.markers
  mark <- mark[mark$p_val < p.cutoff, ]
  mark %>% group_by(cluster) %>% top_n(n, avg_diff) -> topn
  # setting slim.col.label to TRUE will print just the cluster IDS instead of every cell name
  DoHeatmap(srt, genes.use = topn$gene, order.by.ident = TRUE, 
            slim.col.label = TRUE, remove.key = TRUE, draw.line = T)
}
```


## Semi-supervised clustering of cells
```{r}
FindClustersSemi <- function(srt, mtx, k.iter = 5:50) {
    markers <- rownames(mtx)
    nmark <- nrow(mtx)
    ans <- NULL
    minscore <- 100000000
    which.min <- NULL
    for(k in k.iter) {
        # Find clusters
        print(paste0("k = ",k))
        tmp <- FindClusters(srt, reuse.SNN = F, pc.use = srt@pcs.to.keep, k.param = k, print.output = F)
        nclust <- length(unique(tmp@ident))
        print(paste0("Num clusters = ", nclust))
        
        # Finds DE genes
        tmp <- FindAllMarkers(tmp, only.pos=T, thresh.use = .15)
        
        # Gets top 10 DE genes for each cluster
        topdiff <- data.frame(tmp@cluster.markers %>% group_by(cluster) %>% top_n(100,avg_diff))

        # Builds a 1-0 matrix saying if gene is marker for each cluster
        mark.clust <- matrix(NA, nrow = nmark, ncol = nclust)
        for(i in 1:nmark) {
            for(j in 1:nclust) {
                mark.clust[i,j] <- sum(markers[i] %in% topdiff[topdiff$cluster == j - 1,]$gene)
            }
        }
        
        rownames(mark.clust) <- markers
        colnames(mark.clust) <- 1:nclust
        print(mark.clust)
        # Finds how many times each pair of genes is in the matrix
        mark.dist <- matrix(NA, nrow = nmark, ncol = nmark)
        rownames(mark.dist) <- colnames(mark.dist) <- markers
        for(i in 1:nmark) {
            for(j in 1:nmark) {
                mark.dist[i,j] <- sum(mark.clust[i,] & mark.clust[j,])
            }
        }
#        print(mark.dist)
        score <- sum(abs(mtx[markers, markers] - mark.dist[markers, markers]))
        print(paste0("score = ",score))
        if(score < minscore) {
            
            print("--------NEW MIN!!!!--------")
            minscore <- score
            which.min <- k
            ans <- tmp
        }
    }
    
    print(paste0("min score = ", minscore))
    print(paste0("which k min = ", which.min))
    ans
}
```

## Plots a bunch of figures to a directory
```{r}
FigureBomb <- function(srt, markers, out.dir) {
    # PCS
    PCAll(srt, out.path = paste0(out.dir,"/Principal_Components"))
    
    # TSNE
    print(TSNEPlot(srt, do.label=T))
    dev.print(pdf, file = paste0(out.dir, "/TSNE.pdf"), width = 8, height = 4.5)
    
    # Top 20 diff
    diff.heatmap(srt, n = 20, p.cutoff = 1e-2)
    dev.print(pdf, file = paste0(out.dir, "/Top20_DiffExpr.pdf", width = 16, height = 70))
    
    # Top 5 diff
    diff.heatmap(srt, n = 5, p.cutoff = 1e-2)
    dev.print(pdf, file = paste0(out.dir, "/Top5_DiffExpr.pdf", width = 16, height = 30))
    
    # Feature plots of marker genes
    FeatureAll(srt, markers, paste0(out.dir, "/Feature_Plots/markers"))
    
    # Features of top diff
    FeatureTopDiff(srt, paste0(out.dir, "/Feature_Plots/clusters"), n = 10)
    
    # Diff Expr table
    write.table(srt@cluster.markers, file = paste0(out.dir, "/DiffExpr.tsv"), quote=F,sep="\t")
}
```

#################################################################################################
# MONOCLE
#################################################################################################

## Converts Seurat Object into Monocle Object and Run Monocle Pipeline
```{r}
# Creates Monocle object from Seurat data
monocle.from.seurat <- function(srt){
  cerr("Building Monocle Object...")
  mon <- newCellDataSet(as.matrix(srt@raw.data), 
                        phenoData = new("AnnotatedDataFrame", data = srt@data.info),
                        lowerDetectionLimit=1,
                        expressionFamily = negbinomial.size()
  )
  mon@phenoData@data$tree.ident <- as.factor(mon@phenoData@data$tree.ident)
  cerr("Filtering out low expr genes...")
  mon <- detectGenes(mon, min_expr = 0.1)
  expressed_genes <- row.names(subset(fData(mon), num_cells_expressed >= 10))
  
  mon <- setOrderingFilter(mon, srt@var.genes)
  mon <- estimateSizeFactors(mon)
  mon <- estimateDispersions(mon)
  cerr("Running ICA...")
  mon <- reduceDimension(mon, max_components = 2)
  
  cerr("Ordering by pseudotime...")
  mon <- orderCells(mon)
  mon[expressed_genes, ]
}
```

## Filters differential gene test by n cells cutoff and q val cutoff
```{r}
do.dgt <- function(srt, mon) {
  genes.use <- srt@var.genes[srt@var.genes %in% rownames(mon@assayData$exprs)]
  differentialGeneTest(mon[genes.use,], relative_expr = F)
}
dgt.filter <- function(dgt, qval.cutoff = 1, ncells.cutoff = 0) {
  dgt <- dgt[dgt$qval < qval.cutoff, ]
  dgt <- dgt[dgt$num_cells_expressed > ncells.cutoff, ]
  dgt <- dgt[order(dgt$qval),]
  
  dgt
}
```

## Subpath analysis: Selects only a subset of states from a monocle object
```{r}
mon.sub <- function(mon, states) {
  ret <- mon[, mon@phenoData@data$State %in% states]
  ret <- detectGenes(ret, min_expr = 0.1)
  ret <- reduceDimension(ret)
  ret <- orderCells(ret)
  ret
}
```

## Plots expression heatmap for top genes using pheatmap
```{r}
monocle.heatmap <- function(srt, mon, diff) {
  # gets cells in order
  cells.by.pseudotime <- colnames(srt@data)[colnames(srt@data) %in% colnames(mon@assayData$exprs)]
  cells.by.pseudotime <- cells.by.pseudotime[order(mon@phenoData@data[cells.by.pseudotime,"Pseudotime"])]
  genes.top <- rownames(diff)
  anno <- data.frame(Pseudotime = mon@phenoData@data[cells.by.pseudotime, "Pseudotime"])
  rownames(anno) <- cells.by.pseudotime
  
  pheatmap(as.matrix(srt@data[genes.top, cells.by.pseudotime]), 
           cluster_cols = F, cluster_rows = T, 
           show_colnames = F, show_rownames = T, 
           annotation = anno)
}
```

## Plots and saves pseudotime heatmaps
```{r}
PseudotimeFeatureAll <- function(mon, srt, genes, out.dir) {
  mon@phenoData@data[,genes] <- mon@assayData$exprs[genes,]
  for(i in genes) {
    print(plot_cell_trajectory(mon, srt, gene = i))
    dev.print(pdf, file = sprintf(paste0(out.dir,"/%s.pdf"), i), width = 16, height = 9)
  }
}
```

## Plots and saves Monocle genes
```{r}
GeneAll <- function(mon, genes, out.dir) {
  for(i in genes) {
    print(plot_genes_in_pseudotime(mon[i,], relative_expr = F, color_by="tree.ident"))
    dev.print(pdf, file = sprintf(paste0(out.dir, "/%s.pdf"), i))
  }
}

```

## Overrides plot_cell_trajectory to maintain Seurat color scheme
```{r}
plot_cell_trajectory <- function (cds, srt = NULL, x = 1, y = 2, color_by = "tree.ident", gene = NULL) {
    print(gene)
    gene_short_name <- NA
    sample_name <- NA
    data_dim_1 <- NA
    data_dim_2 <- NA
    lib_info_with_pseudo <- pData(cds)
    if (is.null(cds@dim_reduce_type)) {
        stop("Error: dimensionality not yet reduced. Please call reduceDimension() before calling this function.")
    }
    
    # Gets DDRTree low dimension coords
    reduced_dim_coords <- reducedDimK(cds)
    
    # Reduces DDR coordinates to ICA
    ica_space_df <- data.frame(Matrix::t(reduced_dim_coords[c(x, 
        y), ]))
    colnames(ica_space_df) <- c("prin_graph_dim_1", "prin_graph_dim_2")
    ica_space_df$sample_name <- row.names(ica_space_df)
    dp_mst <- minSpanningTree(cds)
    
    edge_list <- as.data.frame(get.edgelist(dp_mst))
    colnames(edge_list) <- c("source", "target")
    edge_df <- merge(ica_space_df, edge_list, by.x = "sample_name", 
        by.y = "source", all = TRUE)
    edge_df <- plyr::rename(edge_df, c(prin_graph_dim_1 = "source_prin_graph_dim_1", 
        prin_graph_dim_2 = "source_prin_graph_dim_2"))
    edge_df <- merge(edge_df, ica_space_df[, c("sample_name", 
        "prin_graph_dim_1", "prin_graph_dim_2")], by.x = "target", 
        by.y = "sample_name", all = TRUE)
    edge_df <- plyr::rename(edge_df, c(prin_graph_dim_1 = "target_prin_graph_dim_1", 
        prin_graph_dim_2 = "target_prin_graph_dim_2"))
    S_matrix <- reducedDimS(cds)
    data_df <- data.frame(t(S_matrix[c(x, y), ]))
    colnames(data_df) <- c("data_dim_1", "data_dim_2")
    data_df$sample_name <- row.names(data_df)
    data_df <- merge(data_df, lib_info_with_pseudo, by.x = "sample_name", 
        by.y = "row.names")
    
    
    tmp <- t(as.matrix(data_df[, c(2, 3)]))
    data_df$data_dim_1 <- tmp[1, ]
    data_df$data_dim_2 <- tmp[2, ]
    tmp <- t(as.matrix(edge_df[, c("source_prin_graph_dim_1", "source_prin_graph_dim_2")]))
    edge_df$source_prin_graph_dim_1 <- tmp[1, ]
    edge_df$source_prin_graph_dim_2 <- tmp[2, ]
    tmp <- t(as.matrix(edge_df[, c("target_prin_graph_dim_1", "target_prin_graph_dim_2")]))
    edge_df$target_prin_graph_dim_1 <- tmp[1, ]
    edge_df$target_prin_graph_dim_2 <- tmp[2, ]
    
    if(is.null(gene)) {
      colors.use <- gg_color_hue(max(as.integer(data_df[,color_by])))
      colors.gg <- colors.use[as.integer(data_df[,color_by])]
    } else {
      data_df[,gene] <- srt@data[gene, data_df$sample_name]
    }
    
    ### PLOT STARTS HERE
    g <- ggplot(data = data_df, aes(x = data_dim_1, y = data_dim_2))
    
    # Tree backbone
    g <- g + geom_segment(colour="grey", aes_string(x = "source_prin_graph_dim_1", 
            y = "source_prin_graph_dim_2", xend = "target_prin_graph_dim_1", 
            yend = "target_prin_graph_dim_2"), size = 0.75, 
            linetype = "solid", na.rm = TRUE, data = edge_df) 
            
    # single cells if colored by metadata
    if(is.null(gene) & !is.null(color_by)) { 
      g <- g + geom_point(colour = colors.gg, size = 1.5, 
            na.rm = TRUE)
    } else {
      g <- g + geom_point(aes_string(color = gene), size = 1.5, 
            na.rm = TRUE) + scale_colour_gradient(low = "darkblue", high = "red")
    }
    
    
    # Gets branching points
    mst_branch_nodes <- cds@auxOrderingData[[cds@dim_reduce_type]]$branch_points
    branch_point_df <- subset(edge_df, sample_name %in% mst_branch_nodes)[, 
        c("sample_name", "source_prin_graph_dim_1", "source_prin_graph_dim_2")]
    branch_point_df$branch_point_idx <- match(branch_point_df$sample_name, 
        mst_branch_nodes)
    branch_point_df <- branch_point_df[!duplicated(branch_point_df$branch_point_idx), 
        ]
    
    # Plots branching points
    g <- g + geom_point(aes_string(x = "source_prin_graph_dim_1", 
        y = "source_prin_graph_dim_2"), size = 5, na.rm = TRUE, 
        data = branch_point_df) + geom_text(aes_string(x = "source_prin_graph_dim_1", 
        y = "source_prin_graph_dim_2", label = "branch_point_idx"), 
        size = 4, color = "white", na.rm = TRUE, data = branch_point_df) +
        theme(axis.line=element_blank(),
      axis.text.x=element_blank(),
      axis.text.y=element_blank(),
      axis.ticks=element_blank(),
      axis.title.x=element_blank(),
      axis.title.y=element_blank())
    g
}
```


#################################################################################################
# WGCNA
#################################################################################################

## Transpose seurat data into WGCNA object
```{r}
# Puts scaled data in WGCNA format
GetDatExpr <- function(srt) {
  genes.use <- unique(srt@cluster.markers$gene)
  t(srt@scale.data[genes.use,])
}
```

## Pick power threshold of correlation
```{r}
# Picks soft threshold power
getSft <- function(datExpr, plot=F) {
  powers <- c(1:10, 2*6:10)
  sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
  
  if(plot){
    par(mfrow = c(1,2))
    cex1 = 0.9;
    
    plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
         xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
         main = paste("Scale independence"));
    text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
         labels=powers,cex=cex1,col="red");
    
    abline(h=0.90,col="red")
    
    plot(sft$fitIndices[,1], sft$fitIndices[,5],
         xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
         main = paste("Mean connectivity"))
    text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
  }
  return(sft)
}
```

## Finds modules of signed network (NEVER USE UNSIGNED FOR SINGLE CELL!!)
```{r}
# Finds modules from raw expression
Modules <- function(datExpr, p) {
  blockwiseModules(datExpr, power = p, TOMType="unsigned", 
                   minModuleSize = 10, deepSplit = 3, pamRespectsDendro = F,  
                   numericLabels = F, minKMEtoStay = 0, saveTOMs = F, verbose = 5)
}
```

## Plots gene dendrogram and module colors
```{r}
# Plots Cluster Dendrogram
PlotNet <- function(net) {
  plotDendroAndColors(net$dendrograms[[1]], net$unmergedColors[net$blocks == 1], dendroLabels = F, "Module colors")
}
```

## Gene heatmaps of specific modules
```{r}
# Heatmap of a specific module
PlotModule <- function(srt, datExpr, net, which) {
  genes <- colnames(datExpr)[net$colors == which]
  if(length(genes) > 200){
    genes <- genes[1:200]
  }
  DoHeatmap(srt, genes.use = genes, order.by.ident = TRUE, slim.col.label = TRUE, remove.key = TRUE, draw.line = T)
}
```

## Prints top genes (based on connectivity) for a given module
```{r}
GetGenesFromModule <- function(datExpr, power, net, which) {
  datExpr <- datExpr[,net$colors == which]
  adj <- adjacency(datExpr, power = power)
  adj <- rowSums(adj)
  
  colnames(datExpr)[order(-adj)]
}
```

## Draws module network using igraph
```{r}
PlotModuleNetwork <- function (datExpr, power, net, which, thresh = .01) {
  dat <- datExpr[, net$colors == which]
  IMConn <- softConnectivity(dat)
  ntop <- min(150, sum(net$colors == which))
  top <- rank(-IMConn) <= ntop

  adj <- adjacency(dat[,top], power = power)
  adj[adj <= thresh] <- 0
  adj[adj >= thresh] <- 1
  diag(adj) <- 0

  gg <- simplify(graph_from_adjacency_matrix(adj, mode="undirected"))
  gg <- delete.vertices(gg, which(degree(gg) == 0)) 
  plot(gg, vertex.size = 4, vertex.label.cex = .8, vertex.label.dist = .3, 
       vertex.color="red", vertex.frame.color="black")
}
```


## Calculates Module Score for all cells
```{r}
ModuleScore <- function(datExpr, power, net, mon) {
    ans <- net$MEs
    rownames(ans) <- rownames(datExpr)
    
    ans$Pseudotime <- mon@phenoData@data[rownames(ans),]$Pseudotime
    ans
}
```

## Plots scores
```{r}
PlotScores <- function(scores, net) {
  X11(width = 16, height = 9)
  plot(NA, xlab = "Pseudotime", ylab="Module score", 
       xlim = c(0, max(scores$Pseudotime)), ylim = c(min(scores[, !(colnames(scores) %in% "Pseudotime")]), max(scores[,!(colnames(scores) %in% "Pseudotime")])))
  
  colors <- c()
  for(i in unique(net$colors)) {
    if(i != "grey"){
        if(sum(net$colors == i)>10) {
          print(i)
          lines(smooth.spline(scores$Pseudotime, scores[,paste0("ME",i)], spar = 0.7), col = i)
          colors <- c(colors, i) 
        }
      }
  }
  legend("topleft", col = colors, legend = colors, lwd=.5, ncol = floor(length(colors)/3), cex = .75,lty=1)
}

```

## ME boxplot
```{r}
BoxMEByCluster <- function(srt, datExpr, net, which) {
  df <- data.frame(net$MEs[,paste0("ME",which)])
  rownames(df) <- rownames(datExpr)
  colors <- gg_color_hue(length(unique(srt@ident)))

  df$cluster <- factor(srt@data.info[rownames(df),]$tree.ident)
  df$color <- colors[df$cluster]
  
  print(head(df))
  
  colnames(df) <- c("module", "cluster", "color")
  
  ggplot(df, aes(cluster, module)) + geom_boxplot(fill = colors)
}
```

## Uses a 2 mixture model to find cells that are + and - for some module
```{r}
SelectMECells <- function(datExpr, net, which) {
  MEs <- net$MEs[, paste0("ME", which)]
  mm <- Mclust(MEs, G = 2)
  
  positive.clust <- which(mm$parameters$mean == max(mm$parameters$mean))
  negative.clust <- which(mm$parameters$mean == min(mm$parameters$mean))
  
  ans <- mm$z[,positive.clust]
  names(ans) <- rownames(datExpr)
  
  ans
}
```

## Returns a data frame that gives +- of every module for all single cells
```{r}
ModuleDF <- function(datExpr, net, p.cutoff = 1e-3) {
  ans <- NULL
  for(i in unique(net$colors)) {
    ans <- cbind(ans, SelectMECells(datExpr, net, i, p.cutoff))
  }
  
  colnames(ans) <- unique(net$colors)
  ans
}
```

#################################################################################################
# RECEPTOR-LIGAND ANALYSIS
#################################################################################################

## Returns full RL matrix given a RL table and a cutoff
```{r}
RLMatrix <- function(srt.data, rl, cutoff = .5) {
    num.cells <- ncol(srt.data)
    ans <- matrix(0, nrow = num.cells, ncol = num.cells)
    rl <- rl[(as.character(rl$Ligand) %in% rownames(srt.data)) & (as.character(rl$Receptor) %in% rownames(srt.data)),]
    rl <- rl[rowSums(as.matrix(srt.data[as.character(rl$Ligand),])>cutoff) > 0 & rowSums(as.matrix(srt.data[as.character(rl$Receptor),])>cutoff) > 0 , ]

    ligand.active <- srt.data[as.character(rl$Ligand),] > cutoff
    receptor.active <- srt.data[as.character(rl$Receptor),] > cutoff

    ans <- t(ligand.active) %*% receptor.active
    rownames(ans) <- colnames(ans) <- colnames(srt.data)
    ans
}
```

## Plots RL interaction network colored by cluster
```{r}
RLPlot <- function(rl.mat, srt, rl.cutoff = 5) {
  num.clusters <- length(unique(srt@ident))
  gg <- graph_from_adjacency_matrix(rl.mat > rl.cutoff, mode="undirected", weighted=T, diag=F, add.colnames=NA)
  V(gg)$size <- 2
  V(gg)$label <- NA
  V(gg)$color <- scales::hue_pal()(num.clusters)[srt@ident]
  gg <- delete.vertices(gg, which(degree(gg) == 0))
  plot(gg, layout = layout.fruchterman.reingold)
}
```

## Finds average interactions between pairs of clusters
```{r}
RLClust <- function(rl, srt) {
  num.clust <- length(unique(srt@ident))
  ans <- matrix(NA, nrow = num.clust, ncol = num.clust)

  for(i in 1:num.clust) {
    for(j in 1:num.clust) {
      ans[i,j] <- sum(rl[srt@ident==i, srt@ident == j])/(sum(srt@ident == i)*sum(srt@ident == j))
    }
  }

  ans
}
```

## Returns a sorted list of RL interactions for two clusters
```{r}
RLList <- function(srt, rl, ca, cb, cutoff = .5, de.only = T){
  # Filters only RLs in dataset
   rl <- rl[(as.character(rl$Ligand) %in% rownames(srt@data)) & (as.character(rl$Receptor) %in% rownames(srt@data)),]
   
   # Filters only RLs in DE list if requested
   if(de.only) {
     genes.lig <- unique(srt@cluster.markers$gene[srt@cluster.markers$cluster == ca])
     genes.rec <- unique(srt@cluster.markers$gene[srt@cluster.markers$cluster == cb])
     rl <- rl[(as.character(rl$Ligand) %in% genes.lig) & (as.character(rl$Receptor) %in% genes.rec),]
   }
   
    if(nrow(rl) > 1) {
      rl <- rl[rowSums(as.matrix(srt@data[as.character(rl$Ligand),])>cutoff) > 0 & rowSums(as.matrix(srt@data[as.character(rl$Receptor),])>cutoff) > 0 , ]
  
      ligands <- rowSums(as.matrix(srt@data[rl$Ligand, srt@ident == ca]) > cutoff)
      receptors <- rowSums(as.matrix(srt@data[rl$Receptor, srt@ident == cb]) > cutoff)
  
      ans <- (ligands * receptors)/((sum(srt@ident == ca))*(sum(srt@ident == cb)))
      names(ans) <- rownames(rl)
      ans <- ans[order(-ans)]
      ans <- ans[ans>0]
        
      return(ans)
    }

    return(NULL)
}

```

#################################################################################################
# SPATIAL RECONSTRUCTION
#################################################################################################

## Plots histogram with density
```{r}
hist.density <- function(srt, gene) {
    vec <- srt@data[gene,]
    plot.new()
    par(mfrow = c(1,2))
    hist(vec, breaks = 100, xlab = "Expression (normalized)", 
         main = paste0("Histogram Expression of ",gene), probability = T)
    
    lines(density(vec), col = "red")
    
    hist(vec[vec > 1e-3], breaks = 100, xlab = "Expression (normalized)", 
         main = paste0("Histogram Expression of ",gene), probability = T)
    lines(density(vec[vec>1e-3]), col = "red")
    
}
```

