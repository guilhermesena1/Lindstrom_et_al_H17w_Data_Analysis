---
title: "Fetal Kidney Data Analysis Functions"
---

# RUN THIS BEFORE EVERYTHING
```{r, message=FALSE, warning=FALSE}
library(Seurat)
library(dplyr)
library(ggplot2)
library(monocle)
library(igraph)
library(pheatmap)
library(WGCNA)
library(mclust)
library(glmnet)

# Cell Cycle Genes
cc.genes <- read.table("info/ccgenes.txt", header=F, stringsAsFactors=F)$V1

# Kidney Marker Genes
marker.genes <- read.table("info/markergenes.txt",header=F, stringsAsFactors = F)$V1

# ligand receptorslib
rl <- read.table("info/receptor_ligands.txt")

# Prints to stderr
cerr <- function (s) {
  write(s, stderr())
}

gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}

```

#################################################################################################
# SEURAT
#################################################################################################

## Helper functions to plot and save many figures
```{r}
# Saves all feature plots
FeatureAll <- function(srt, marker.genes, out.dir) {
  for(i in marker.genes) {
    if(i %in% rownames(srt@scale.data)){
      print(FeaturePlot(srt, i, cols.use = c("darkblue", "red"), no.axes=T, no.legend = F))
      dev.print(pdf, file = sprintf(paste0(out.dir, "/%s.pdf"), i), width = 16, height = 9)
    }
  }
}

FeatureTopDiff <- function(srt, mark, out.dir, n = 10) {
  mark %>% group_by(cluster) %>% top_n(n, avg_logFC) -> topn
  for(i in unique(topn$cluster)) {
      genes <- topn[topn$cluster == i,]$gene
      FeatureAll(srt, genes, sprintf(paste0(out.dir, "/cluster_%s"),i))
  }
}

# Saves all violin plots
ViolinAll <- function(srt, marker.genes, out.dir) {
  for(i in marker.genes) {
    if(i %in% rownames(srt@scale.data)){
      print(VlnPlot(srt, i))
      dev.print(pdf, file = sprintf(paste0(out.dir, "/%s.pdf"), i), width = 16, height = 9)
    }
  }
}

# Save all PCs
PCAll <- function(srt, out.path) {
  print(out.path)
  for(i in 1:48) {
    print(PCHeatmap(srt, pc.use = i, cells.use = 100, do.balanced = T, label.columns = F))
    dev.print(pdf, file = sprintf(paste0(out.path, "/PC%s.pdf"), i), width = 9, height = 15)
  }
  
  # Saves jackstraw as well
  print(JackStrawPlot(srt, PCs = 1:50))
  dev.print(pdf, file = paste0(out.path, "/JackStraw.pdf"), width = 9, height = 25)
}
```

## Heatmap of top DE genes based on average difference
```{r}
diff.heatmap <- function(srt, mark, n = 20, p.cutoff = 1e-5) {
  mark <- mark[mark$p_val_adj < p.cutoff, ]
  mark %>% group_by(cluster) %>% top_n(n, avg_logFC) -> topn
  # setting slim.col.label to TRUE will print just the cluster IDS instead of every cell name
  DoHeatmap(srt, genes.use = topn$gene,  
            slim.col.label = TRUE, remove.key = TRUE, draw.line = T)
}
```


## Semi-supervised clustering of cells
```{r}
FindClustersSemi <- function(srt, mtx, k.iter = 5:50) {
    markers <- rownames(mtx)
    nmark <- nrow(mtx)
    ans <- NULL
    minscore <- 100000000
    which.min <- NULL
    for(k in k.iter) {
        # Find clusters
        print(paste0("k = ",k))
        tmp <- FindClusters(srt, reuse.SNN = F, pc.use = srt@pcs.to.keep, k.param = k, print.output = F)
        nclust <- length(unique(tmp@ident))
        print(paste0("Num clusters = ", nclust))
        
        # Finds DE genes
        tmp <- FindAllMarkers(tmp, only.pos=T, thresh.use = .15)
        
        # Gets top 10 DE genes for each cluster
        topdiff <- data.frame(tmp@cluster.markers %>% group_by(cluster) %>% top_n(100,avg_diff))

        # Builds a 1-0 matrix saying if gene is marker for each cluster
        mark.clust <- matrix(NA, nrow = nmark, ncol = nclust)
        for(i in 1:nmark) {
            for(j in 1:nclust) {
                mark.clust[i,j] <- sum(markers[i] %in% topdiff[topdiff$cluster == j - 1,]$gene)
            }
        }
        
        rownames(mark.clust) <- markers
        colnames(mark.clust) <- 1:nclust
        print(mark.clust)
        # Finds how many times each pair of genes is in the matrix
        mark.dist <- matrix(NA, nrow = nmark, ncol = nmark)
        rownames(mark.dist) <- colnames(mark.dist) <- markers
        for(i in 1:nmark) {
            for(j in 1:nmark) {
                mark.dist[i,j] <- sum(mark.clust[i,] & mark.clust[j,])
            }
        }
#        print(mark.dist)
        score <- sum(abs(mtx[markers, markers] - mark.dist[markers, markers]))
        print(paste0("score = ",score))
        if(score < minscore) {
            
            print("--------NEW MIN!!!!--------")
            minscore <- score
            which.min <- k
            ans <- tmp
        }
    }
    
    print(paste0("min score = ", minscore))
    print(paste0("which k min = ", which.min))
    ans
}
```

## Plots a bunch of figures to a directory
```{r}
FigureBomb <- function(srt, diffexp, markers, out.dir, do.pcs = T, do.tsne = T, 
                       do.markers = T, do.topclusts = T,
                       do.top5 = T, do.top20 = T) {
    # PCS
    if(do.pcs) {
        PCAll(srt, out.path = paste0(out.dir,"/Principal_Components"))
    }
    
    # TSNE
    if(do.tsne) {
        print(TSNEPlot(srt, do.label=T))
        dev.print(pdf, file = paste0(out.dir, "/TSNE.pdf"), width = 16, height = 9)
    }
    
    # Top 20 diff
    if(do.top20) {
        diff.heatmap(srt, diffexp, n = 20, p.cutoff = 1e-2)
        dev.print(pdf, file = paste0(out.dir, "/Top20_DiffExpr.pdf", width = 16, height = 70))
    }
    
    # Top 5 diff
    if(do.top5) {
        diff.heatmap(srt, diffexp, n = 5, p.cutoff = 1e-2)
        dev.print(pdf, file = paste0(out.dir, "/Top5_DiffExpr.pdf", width = 16, height = 30))
    }
    
    # Feature plots of marker genes
    if(do.markers){
        FeatureAll(srt, markers, paste0(out.dir, "/Feature_Plots/markers"))
    }
    
    # Features of top diff
    if(do.topclusts) {
        FeatureTopDiff(srt, diffexp, paste0(out.dir, "/Feature_Plots/clusters"), n = 10)
    }
    # Diff Expr table
    write.table(diffexp, file = paste0(out.dir, "/DiffExpr.tsv"), quote=F,sep="\t")
}
```

## Plot Feature from metadata
```{r}
TSNEPlotFeature <- function(srt, feats) {
    plotlist <- list()
    for(which in feats) {
        df <- data.frame(x = srt@dr$tsne@cell.embeddings[,1], 
                         y = srt@dr$tsne@cell.embeddings[,2], 
                         feat = as.numeric(srt@meta.data[, which]))
    
        plotlist[[which]] <- ggplot(df, aes(x = x, y = y, color = feat)) + 
            geom_point() + 
            scale_colour_gradient(low = "lightgray", high = "red", na.value = "red") + 
            ggtitle(which)
    }
    
    multiplot(plotlist = plotlist, cols = floor(sqrt(length(plotlist))))
}
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}
```

```{r}
PlotUnique <- function(srt, diffexp, out.dir, do.violin = F) {
    genes <- diffexp$gene
    unique.genes <- genes[!(duplicated(genes) | duplicated(genes, fromLast=T))]
    for(i in unique(diffexp$cluster)) {
        genes.plot <- unique(diffexp$gene[diffexp$cluster == i])
        genes.plot <- genes.plot[genes.plot %in% unique.genes]
        genes.plot <- genes.plot[1:(min(50, length(genes.plot)))]
        if(!do.violin) {
            FeatureAll(srt, genes.plot, paste0(out.dir, "/cluster_",i))
        } else {
            ViolinAll(srt, genes.plot, paste0(out.dir, "/cluster_",i))
        }
    }
}
```


## Adds iteration to tSNE
```{r}
RunMoreTSNE <- function(srt, n.iter = 1000, pcs.use = 1:50, verbose = T) {
    res <- Rtsne(srt@dr$pca@cell.embeddings[, pcs.use], 
                 max_iter = n.iter, 
                 pca = F, 
                 Y_init = srt@dr$tsne@cell.embeddings,
                 verbose = verbose)$Y
    
    colnames(res) <- c("tSNE_1", "tSNE_2")
    rownames(res) <- rownames(srt@dr$pca@cell.embeddings)
    
    srt@dr$tsne@cell.embeddings <- res
    
    srt
}
```


#################################################################################################
# MONOCLE
#################################################################################################

## Converts Seurat Object into Monocle Object and Run Monocle Pipeline
```{r}
# Creates Monocle object from Seurat data
monocle.from.seurat <- function(srt){
  cerr("Building Monocle Object...")
  mon <- newCellDataSet(as.matrix(srt@raw.data), 
                        phenoData = new("AnnotatedDataFrame", data = srt@data.info),
                        lowerDetectionLimit=1,
                        expressionFamily = negbinomial.size()
  )
  mon@phenoData@data$tree.ident <- as.factor(mon@phenoData@data$tree.ident)
  cerr("Filtering out low expr genes...")
  mon <- detectGenes(mon, min_expr = 0.1)
  expressed_genes <- row.names(subset(fData(mon), num_cells_expressed >= 10))
  
  mon <- setOrderingFilter(mon, srt@var.genes)
  mon <- estimateSizeFactors(mon)
  mon <- estimateDispersions(mon)
  cerr("Running ICA...")
  mon <- reduceDimension(mon, max_components = 2)
  
  cerr("Ordering by pseudotime...")
  mon <- orderCells(mon)
  mon[expressed_genes, ]
}
```

## Filters differential gene test by n cells cutoff and q val cutoff
```{r}
do.dgt <- function(srt, mon) {
  genes.use <- srt@var.genes[srt@var.genes %in% rownames(mon@assayData$exprs)]
  differentialGeneTest(mon[genes.use,], relative_expr = F)
}
dgt.filter <- function(dgt, qval.cutoff = 1, ncells.cutoff = 0) {
  dgt <- dgt[dgt$qval < qval.cutoff, ]
  dgt <- dgt[dgt$num_cells_expressed > ncells.cutoff, ]
  dgt <- dgt[order(dgt$qval),]
  
  dgt
}
```

## Subpath analysis: Selects only a subset of states from a monocle object
```{r}
mon.sub <- function(mon, states) {
  ret <- mon[, mon@phenoData@data$State %in% states]
  ret <- detectGenes(ret, min_expr = 0.1)
  ret <- reduceDimension(ret)
  ret <- orderCells(ret)
  ret
}
```

## Plots expression heatmap for top genes using pheatmap
```{r}
monocle.heatmap <- function(srt, mon, diff) {
  # gets cells in order
  cells.by.pseudotime <- colnames(srt@data)[colnames(srt@data) %in% colnames(mon@assayData$exprs)]
  cells.by.pseudotime <- cells.by.pseudotime[order(mon@phenoData@data[cells.by.pseudotime,"Pseudotime"])]
  genes.top <- rownames(diff)
  anno <- data.frame(Pseudotime = mon@phenoData@data[cells.by.pseudotime, "Pseudotime"])
  rownames(anno) <- cells.by.pseudotime
  
  pheatmap(as.matrix(srt@data[genes.top, cells.by.pseudotime]), 
           cluster_cols = F, cluster_rows = T, 
           show_colnames = F, show_rownames = T, 
           annotation = anno)
}
```

## Plots and saves pseudotime heatmaps
```{r}
PseudotimeFeatureAll <- function(mon, srt, genes, out.dir) {
  mon@phenoData@data[,genes] <- mon@assayData$exprs[genes,]
  for(i in genes) {
    print(plot_cell_trajectory(mon, srt, gene = i))
    dev.print(pdf, file = sprintf(paste0(out.dir,"/%s.pdf"), i), width = 16, height = 9)
  }
}
```

## Plots and saves Monocle genes
```{r}
GeneAll <- function(mon, genes, out.dir) {
  for(i in genes) {
    print(plot_genes_in_pseudotime(mon[i,], relative_expr = F, color_by="tree.ident"))
    dev.print(pdf, file = sprintf(paste0(out.dir, "/%s.pdf"), i))
  }
}

```

## Overrides plot_cell_trajectory to maintain Seurat color scheme
```{r}
plot_cell_trajectory <- function (cds, srt = NULL, x = 1, y = 2, color_by = "tree.ident", gene = NULL) {
    print(gene)
    gene_short_name <- NA
    sample_name <- NA
    data_dim_1 <- NA
    data_dim_2 <- NA
    lib_info_with_pseudo <- pData(cds)
    if (is.null(cds@dim_reduce_type)) {
        stop("Error: dimensionality not yet reduced. Please call reduceDimension() before calling this function.")
    }
    
    # Gets DDRTree low dimension coords
    reduced_dim_coords <- reducedDimK(cds)
    
    # Reduces DDR coordinates to ICA
    ica_space_df <- data.frame(Matrix::t(reduced_dim_coords[c(x, 
        y), ]))
    colnames(ica_space_df) <- c("prin_graph_dim_1", "prin_graph_dim_2")
    ica_space_df$sample_name <- row.names(ica_space_df)
    dp_mst <- minSpanningTree(cds)
    
    edge_list <- as.data.frame(get.edgelist(dp_mst))
    colnames(edge_list) <- c("source", "target")
    edge_df <- merge(ica_space_df, edge_list, by.x = "sample_name", 
        by.y = "source", all = TRUE)
    edge_df <- plyr::rename(edge_df, c(prin_graph_dim_1 = "source_prin_graph_dim_1", 
        prin_graph_dim_2 = "source_prin_graph_dim_2"))
    edge_df <- merge(edge_df, ica_space_df[, c("sample_name", 
        "prin_graph_dim_1", "prin_graph_dim_2")], by.x = "target", 
        by.y = "sample_name", all = TRUE)
    edge_df <- plyr::rename(edge_df, c(prin_graph_dim_1 = "target_prin_graph_dim_1", 
        prin_graph_dim_2 = "target_prin_graph_dim_2"))
    S_matrix <- reducedDimS(cds)
    data_df <- data.frame(t(S_matrix[c(x, y), ]))
    colnames(data_df) <- c("data_dim_1", "data_dim_2")
    data_df$sample_name <- row.names(data_df)
    data_df <- merge(data_df, lib_info_with_pseudo, by.x = "sample_name", 
        by.y = "row.names")
    
    
    tmp <- t(as.matrix(data_df[, c(2, 3)]))
    data_df$data_dim_1 <- tmp[1, ]
    data_df$data_dim_2 <- tmp[2, ]
    tmp <- t(as.matrix(edge_df[, c("source_prin_graph_dim_1", "source_prin_graph_dim_2")]))
    edge_df$source_prin_graph_dim_1 <- tmp[1, ]
    edge_df$source_prin_graph_dim_2 <- tmp[2, ]
    tmp <- t(as.matrix(edge_df[, c("target_prin_graph_dim_1", "target_prin_graph_dim_2")]))
    edge_df$target_prin_graph_dim_1 <- tmp[1, ]
    edge_df$target_prin_graph_dim_2 <- tmp[2, ]
    
    if(is.null(gene)) {
      colors.use <- gg_color_hue(max(as.integer(data_df[,color_by])))
      colors.gg <- colors.use[as.integer(data_df[,color_by])]
    } else {
      data_df[,gene] <- srt@data[gene, data_df$sample_name]
    }
    
    ### PLOT STARTS HERE
    g <- ggplot(data = data_df, aes(x = data_dim_1, y = data_dim_2))
    
    # Tree backbone
    g <- g + geom_segment(colour="grey", aes_string(x = "source_prin_graph_dim_1", 
            y = "source_prin_graph_dim_2", xend = "target_prin_graph_dim_1", 
            yend = "target_prin_graph_dim_2"), size = 0.75, 
            linetype = "solid", na.rm = TRUE, data = edge_df) 
            
    # single cells if colored by metadata
    if(is.null(gene) & !is.null(color_by)) { 
      g <- g + geom_point(colour = colors.gg, size = 1.5, 
            na.rm = TRUE)
    } else {
      g <- g + geom_point(aes_string(color = gene), size = 1.5, 
            na.rm = TRUE) + scale_colour_gradient(low = "darkblue", high = "red")
    }
    
    
    # Gets branching points
    mst_branch_nodes <- cds@auxOrderingData[[cds@dim_reduce_type]]$branch_points
    branch_point_df <- subset(edge_df, sample_name %in% mst_branch_nodes)[, 
        c("sample_name", "source_prin_graph_dim_1", "source_prin_graph_dim_2")]
    branch_point_df$branch_point_idx <- match(branch_point_df$sample_name, 
        mst_branch_nodes)
    branch_point_df <- branch_point_df[!duplicated(branch_point_df$branch_point_idx), 
        ]
    
    # Plots branching points
    g <- g + geom_point(aes_string(x = "source_prin_graph_dim_1", 
        y = "source_prin_graph_dim_2"), size = 5, na.rm = TRUE, 
        data = branch_point_df) + geom_text(aes_string(x = "source_prin_graph_dim_1", 
        y = "source_prin_graph_dim_2", label = "branch_point_idx"), 
        size = 4, color = "white", na.rm = TRUE, data = branch_point_df) +
        theme(axis.line=element_blank(),
      axis.text.x=element_blank(),
      axis.text.y=element_blank(),
      axis.ticks=element_blank(),
      axis.title.x=element_blank(),
      axis.title.y=element_blank())
    g
}
```


#################################################################################################
# WGCNA
#################################################################################################

## Transpose seurat data into WGCNA object
```{r}
# Puts scaled data in WGCNA format
GetDatExpr <- function(srt) {
  genes.use <- unique(srt@cluster.markers$gene)
  t(srt@scale.data[genes.use,])
}
```

## Pick power threshold of correlation
```{r}
# Picks soft threshold power
getSft <- function(datExpr, plot=F) {
  powers <- c(1:10, 2*6:10)
  sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
  
  if(plot){
    par(mfrow = c(1,2))
    cex1 = 0.9;
    
    plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
         xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
         main = paste("Scale independence"));
    text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
         labels=powers,cex=cex1,col="red");
    
    abline(h=0.90,col="red")
    
    plot(sft$fitIndices[,1], sft$fitIndices[,5],
         xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
         main = paste("Mean connectivity"))
    text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
  }
  return(sft)
}
```

## Finds modules of signed network (NEVER USE UNSIGNED FOR SINGLE CELL!!)
```{r}
# Finds modules from raw expression
Modules <- function(datExpr, p) {
  blockwiseModules(datExpr, power = p, TOMType="unsigned", 
                   minModuleSize = 10, deepSplit = 3, pamRespectsDendro = F,  
                   numericLabels = F, minKMEtoStay = 0, saveTOMs = F, verbose = 5)
}
```

## Plots gene dendrogram and module colors
```{r}
# Plots Cluster Dendrogram
PlotNet <- function(net) {
  plotDendroAndColors(net$dendrograms[[1]], net$unmergedColors[net$blocks == 1], dendroLabels = F, "Module colors")
}
```

## Gene heatmaps of specific modules
```{r}
# Heatmap of a specific module
PlotModule <- function(srt, datExpr, net, which) {
  genes <- colnames(datExpr)[net$colors == which]
  if(length(genes) > 200){
    genes <- genes[1:200]
  }
  DoHeatmap(srt, genes.use = genes, order.by.ident = TRUE, slim.col.label = TRUE, remove.key = TRUE, draw.line = T)
}
```

## Prints top genes (based on connectivity) for a given module
```{r}
GetGenesFromModule <- function(datExpr, power, net, which) {
  datExpr <- datExpr[,net$colors == which]
  adj <- adjacency(datExpr, power = power)
  adj <- rowSums(adj)
  
  colnames(datExpr)[order(-adj)]
}
```

## Draws module network using igraph
```{r}
PlotModuleNetwork <- function (datExpr, power, net, which, thresh = .01) {
  dat <- datExpr[, net$colors == which]
  IMConn <- softConnectivity(dat)
  ntop <- min(150, sum(net$colors == which))
  top <- rank(-IMConn) <= ntop

  adj <- adjacency(dat[,top], power = power)
  adj[adj <= thresh] <- 0
  adj[adj >= thresh] <- 1
  diag(adj) <- 0

  gg <- simplify(graph_from_adjacency_matrix(adj, mode="undirected"))
  gg <- delete.vertices(gg, which(degree(gg) == 0)) 
  plot(gg, vertex.size = 4, vertex.label.cex = .8, vertex.label.dist = .3, 
       vertex.color="red", vertex.frame.color="black")
}
```


## Calculates Module Score for all cells
```{r}
ModuleScore <- function(datExpr, power, net, mon) {
    ans <- net$MEs
    rownames(ans) <- rownames(datExpr)
    
    ans$Pseudotime <- mon@phenoData@data[rownames(ans),]$Pseudotime
    ans
}
```

## Plots scores
```{r}
PlotScores <- function(scores, net) {
  X11(width = 16, height = 9)
  plot(NA, xlab = "Pseudotime", ylab="Module score", 
       xlim = c(0, max(scores$Pseudotime)), ylim = c(min(scores[, !(colnames(scores) %in% "Pseudotime")]), max(scores[,!(colnames(scores) %in% "Pseudotime")])))
  
  colors <- c()
  for(i in unique(net$colors)) {
    if(i != "grey"){
        if(sum(net$colors == i)>10) {
          print(i)
          lines(smooth.spline(scores$Pseudotime, scores[,paste0("ME",i)], spar = 0.7), col = i)
          colors <- c(colors, i) 
        }
      }
  }
  legend("topleft", col = colors, legend = colors, lwd=.5, ncol = floor(length(colors)/3), cex = .75,lty=1)
}

```

## ME boxplot
```{r}
BoxMEByCluster <- function(srt, datExpr, net, which) {
  df <- data.frame(net$MEs[,paste0("ME",which)])
  rownames(df) <- rownames(datExpr)
  colors <- gg_color_hue(length(unique(srt@ident)))

  df$cluster <- factor(srt@data.info[rownames(df),]$tree.ident)
  df$color <- colors[df$cluster]
  
  print(head(df))
  
  colnames(df) <- c("module", "cluster", "color")
  
  ggplot(df, aes(cluster, module)) + geom_boxplot(fill = colors)
}
```

## Uses a 2 mixture model to find cells that are + and - for some module
```{r}
SelectMECells <- function(datExpr, net, which) {
  MEs <- net$MEs[, paste0("ME", which)]
  mm <- Mclust(MEs, G = 2)
  
  positive.clust <- which(mm$parameters$mean == max(mm$parameters$mean))
  negative.clust <- which(mm$parameters$mean == min(mm$parameters$mean))
  
  ans <- mm$z[,positive.clust]
  names(ans) <- rownames(datExpr)
  
  ans
}
```

## Returns a data frame that gives +- of every module for all single cells
```{r}
ModuleDF <- function(datExpr, net, p.cutoff = 1e-3) {
  ans <- NULL
  for(i in unique(net$colors)) {
    ans <- cbind(ans, SelectMECells(datExpr, net, i, p.cutoff))
  }
  
  colnames(ans) <- unique(net$colors)
  ans
}
```

#################################################################################################
# RECEPTOR-LIGAND ANALYSIS
#################################################################################################

## Returns full RL matrix given a RL table and a cutoff
```{r}
RLMatrix <- function(srt.data, rl, cutoff = .5) {
    num.cells <- ncol(srt.data)
    ans <- matrix(0, nrow = num.cells, ncol = num.cells)
    rl <- rl[(as.character(rl$Ligand) %in% rownames(srt.data)) & (as.character(rl$Receptor) %in% rownames(srt.data)),]
    rl <- rl[rowSums(as.matrix(srt.data[as.character(rl$Ligand),])>cutoff) > 0 & rowSums(as.matrix(srt.data[as.character(rl$Receptor),])>cutoff) > 0 , ]

    ligand.active <- srt.data[as.character(rl$Ligand),] > cutoff
    receptor.active <- srt.data[as.character(rl$Receptor),] > cutoff

    ans <- t(ligand.active) %*% receptor.active
    rownames(ans) <- colnames(ans) <- colnames(srt.data)
    ans
}
```

## Plots RL interaction network colored by cluster
```{r}
RLPlot <- function(rl.mat, srt, rl.cutoff = 5) {
  num.clusters <- length(unique(srt@ident))
  gg <- graph_from_adjacency_matrix(rl.mat > rl.cutoff, mode="undirected", weighted=T, diag=F, add.colnames=NA)
  V(gg)$size <- 2
  V(gg)$label <- NA
  V(gg)$color <- scales::hue_pal()(num.clusters)[srt@ident]
  gg <- delete.vertices(gg, which(degree(gg) == 0))
  plot(gg, layout = layout.fruchterman.reingold)
}
```

## Finds average interactions between pairs of clusters
```{r}
RLClust <- function(rl, srt) {
  num.clust <- length(unique(srt@ident))
  ans <- matrix(NA, nrow = num.clust, ncol = num.clust)

  for(i in 1:num.clust) {
    for(j in 1:num.clust) {
      ans[i,j] <- sum(rl[srt@ident==i, srt@ident == j])/(sum(srt@ident == i)*sum(srt@ident == j))
    }
  }

  ans
}
```

## Returns a sorted list of RL interactions for two clusters
```{r}
RLList <- function(srt, rl, ca, cb, cutoff = .5, de.only = T){
  # Filters only RLs in dataset
   rl <- rl[(as.character(rl$Ligand) %in% rownames(srt@data)) & (as.character(rl$Receptor) %in% rownames(srt@data)),]
   
   # Filters only RLs in DE list if requested
   if(de.only) {
     genes.lig <- unique(srt@cluster.markers$gene[srt@cluster.markers$cluster == ca])
     genes.rec <- unique(srt@cluster.markers$gene[srt@cluster.markers$cluster == cb])
     rl <- rl[(as.character(rl$Ligand) %in% genes.lig) & (as.character(rl$Receptor) %in% genes.rec),]
   }
   
    if(nrow(rl) > 1) {
      rl <- rl[rowSums(as.matrix(srt@data[as.character(rl$Ligand),])>cutoff) > 0 & rowSums(as.matrix(srt@data[as.character(rl$Receptor),])>cutoff) > 0 , ]
  
      ligands <- rowSums(as.matrix(srt@data[rl$Ligand, srt@ident == ca]) > cutoff)
      receptors <- rowSums(as.matrix(srt@data[rl$Receptor, srt@ident == cb]) > cutoff)
  
      ans <- (ligands * receptors)/((sum(srt@ident == ca))*(sum(srt@ident == cb)))
      names(ans) <- rownames(rl)
      ans <- ans[order(-ans)]
      ans <- ans[ans>0]
        
      return(ans)
    }

    return(NULL)
}

```

#################################################################################################
# SPATIAL RECONSTRUCTION
#################################################################################################

## Plots histogram with density
```{r}
hist.density <- function(srt, gene) {
    if(gene %in% rownames(srt@data)) {
        vec <- srt@data[gene,]
        
        mcl <- Mclust(vec[vec>0], G = 1:10)
        print(paste0("Num levels: ", mcl$G))
        
        plot.new()
        par(mfrow=c(1,2))
        hist(vec, breaks = 100, xlab = "Expression (normalized)", 
             main = paste0(gene, ". Levels = ", mcl$G), probability = T)
        
        lines(density(vec), col = "red")
        
        hist(vec[vec > 0], breaks = 100, xlab = "Nonzero Expression (normalized)", 
             main = paste0(gene, ". Levels = ", mcl$G), probability = T)
        lines(density(vec[vec > 0]), col = "red")
        
    } else {
        print(paste0("Gene ", gene, " not expressed"))
    }
}
```

## Calculates MCC based on binary reference
```{r}
mcc.bin.scores <- function(df, levels, q = .4) {
    ans <- matrix(NA, nrow = ncol(df), ncol = nrow(levels))
    rownames(ans) <- colnames(df)
    colnames(ans) <- paste0("bin_", rownames(levels))
    
    genes <- colnames(levels)
    genes <- genes[genes %in% rownames(df)]
    
    
    df <- t(apply(df, 1, function (x){
        if(var(x) > 0.01){
            return(Mclust(x, G = 2)$z[,2])
        }
        return (rep(0, length(x)))
    }))

    levels <- levels > 0
    
    for(i in rownames(levels)) {
        print(paste0("level ", i))
        ans[,paste0("bin_",i)] <- apply(df, 2, 
            function(x){ 
               MCC.prob(x, levels[i,])
            })
    }
    
    ans
}
```

## Makes boxplot of MCC values by cluster
```{r}
BoxFeatureByCluster <- function(srt, which) {
  df <- srt@meta.data[, which]
  df[is.infinite(df)] <- max(df[!is.infinite(df)])
  df <- data.frame(df)
  rownames(df) <- rownames(srt@meta.data)
  colors <- gg_color_hue(length(unique(srt@ident)))

  df$cluster <- factor(srt@ident)
  df$color <- colors[df$cluster]
  
  
  colnames(df) <- c("feature", "cluster", "color")
  print(head(df))
  
  ggplot(df, aes(cluster, feature)) + geom_boxplot(fill = colors) + ylab(which)
}
```


## Imputation of genes using LASSO
```{r}
impute.lasso <- function(srt, gene) {
    genes.all <- rownames(srt@data)
    genes.use <- genes.all[genes.all != gene]
    ta <- t(srt@data[genes.use,])
    tb <- srt@data[gene,]
    tryCatch({
        fit <- cv.glmnet(ta, tb)
        nonzero <- sum( predict(fit, ta, type="coefficients") > 0)
        print(paste0(nonzero, " nonzero genes for ", gene))
        predict(fit, ta, type = "response", s = fit$lambda.min)
    }, error = function(err) { print(err); return(tb)} )
}
```

## Fills the @imputed slot on the seurat object
```{r}
ImputeMarkers <- function(srt, markers) {
    # ImpÃºte with CV Lasso
    srt@imputed <- data.frame(sapply(as.character(markers), function(x) {impute.lasso(srt, x)}))
    
    # Converts to 2 mixture model
    # srt@imputed <- data.frame(apply(srt@imputed, 2, function(x) {
    #    Mclust(x, G = 2)$classification
    #}))
    
    rownames(srt@imputed) <- colnames(srt@data)
    colnames(srt@imputed) <- markers
    srt
}

```

## Calculates MCC
```{r}
MCC <- function(truth, sample) {
    tp <- sum(truth & sample)
    fp <- sum(truth & !sample)
    fn <- sum(!truth & sample)
    tn <- sum(!truth & !sample)
    den <- sqrt((tp+fp)*(tp+fn)*(tn+fp)*(tn+fn))
    if(den == 0) {
        return (0)
    }
    ans <- (tp*tn - fp*fn)/den

    ans
}
```

## Probabilistic MCC
```{r}
MCC.prob <- function(sample, truth) {
    prob.on <- sample
    prob.off <- 1 - sample
    tp <- sum(prob.on[truth])
    tn <- sum(prob.off[!truth])
    fp <- sum(prob.on[!truth])
    fn <- sum(prob.off[truth])
    
    den <- sqrt((tp+fp)*(tp+fn)*(tn+fp)*(tn+fn))
    if(den == 0) {
        return (0)
    }
    ans <- (tp*tn - fp*fn)/den

    ans
}
```


## Null model construction: Permutate dataset
```{r}
permutate.markers <- function(srt, markers, n.times = 50) {
    df <- t(srt@imputed)
    ans <- NULL
    for(i in 1:n.times) {
        print(i)
        ans <- cbind(ans, t(apply(df, 1, sample)))
    }
    
    ans
}
```

## Cell p-values based on null model
```{r}
pval.null <- function(df, null.model) {
    ecdfs <- list()
    for(i in 1:ncol(null.model)) {
      ecdfs[[i]] <- ecdf(null.model[,i])
    }
    
    apply(df, 1, function(x) {
        ans <- rep(0, ncol(null.model))
        for(i in 1:ncol(null.model)) {
          ans [i]<- 1 - ecdfs[[i]](x[i]) 
        }
        ans
    })
}
```


```{r}
SelectPositiveCells <- function(srt, pvals, fdr = .1) {
    ans <- matrix(NA, nrow = nrow(pvals), ncol = ncol(srt@data))
    colnames(ans) <- colnames(srt@data)
    rownames(ans) <- rownames(pvals)
    
    for(i in 1:nrow(pvals)) {
        fs <- 1:ncol(ans)*fdr/ncol(ans)
        ps <- sort(pvals[i,])
        select <- (ps <= fs)
        names(select) <- names(ps)
        ans[i,] <- select[colnames(ans)]
    }
    
    ans
}
```

## Runs spatial reconstruction on seurat object
```{r}
DoSpatialReconstruction <- function(srt, levels, 
                                    num.shuffle = 100, fdr = .1, 
                                    q = 0, do.overwrite = F,
                                    mcc.null = NULL) {
    genes <- colnames(levels)
    
    if(is.null(mcc.null)) {
        write("permutating data", stderr())
        df.null <- permutate.markers(srt, colnames(levels), num.shuffle)
        write("Calculating MCCs for null", stderr())
        mcc.null <- mcc.bin.scores(df.null, levels, q = q)
    }
    
    write("Calculating MCCs for data", stderr())
    mcc.df <-  mcc.bin.scores(srt@data[genes,], levels, q = q)
    
    write("Finding p values", stderr())
    pvals <- pval.null(mcc.df, mcc.null)
    
    write(paste0("Selecting positive cells with fdr ", fdr), stderr())
    cells.select <- SelectPositiveCells(srt, pvals, fdr)
        
    if(do.overwrite) {
        for(i in 1:nrow(levels)) {
            srt <- AddMetaData(srt, -log(pvals[i,]), paste0("logp_",i))
        }
        
        for(i in 1:nrow(levels)) {
            srt <- AddMetaData(srt, cells.select[i,], paste0("keep_",i,"_fdr_",fdr))
        }
        return(srt)
    }
    
    return(sum(colSums(cells.select)>0))
}
```


```{r}
BestSpatialReconstruction <- function(srt, levels, num.shuffle = 100, fdr = .1, quantiles = seq(from = 0, to = 1, length.out = 20)) {
    best.q <- 0
    max.num <- 0
    for(q in quantiles) {
        num <- DoSpatialReconstruction(srt, levels, num.shuffle, .1, q, F)
        print(paste0("Cells for quantile ",q," = ", num))
        if(num > max.num ){
            max.num <- num
            best.q <- q
        }
    }
    
    DoSpatialReconstruction(srt, levels, num.shuffle, fdr, best.q, do.overwrite = T)
}
```


```{r}
vst <- function(x, a, b, c) {
    log(2*sqrt(a)*sqrt(x*(a*x+b)+c)+2*a*x+b)/sqrt(a)
}
```

