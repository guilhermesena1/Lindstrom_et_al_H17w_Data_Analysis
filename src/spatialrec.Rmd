

#################################################################################################
# SPATIAL RECONSTRUCTION
#################################################################################################

## Image specific libraries
```{r}
library(oro.nifti) # to read nii files
library(preprocessCore) # For quantile normalization
```


## Plots histogram with density
```{r}
hist.density <- function(srt, gene) {
    if(gene %in% rownames(srt@data)) {
        vec <- srt@data[gene,]
        
        mcl <- Mclust(vec[vec>0], G = 1:10)
        print(paste0("Num levels: ", mcl$G))
        
        plot.new()
        par(mfrow=c(1,2))
        hist(vec, breaks = 100, xlab = "Expression (normalized)", 
             main = paste0(gene, ". Levels = ", mcl$G), probability = T)
        
        lines(density(vec), col = "red")
        
        hist(vec[vec > 0], breaks = 100, xlab = "Nonzero Expression (normalized)", 
             main = paste0(gene, ". Levels = ", mcl$G), probability = T)
        lines(density(vec[vec > 0]), col = "red")
        
    } else {
        print(paste0("Gene ", gene, " not expressed"))
    }
}
```

## Calculates MCC based on binary reference
```{r}
mcc.bin.scores <- function(df, levels, q = .4) {
    ans <- matrix(NA, nrow = ncol(df), ncol = nrow(levels))
    rownames(ans) <- colnames(df)
    colnames(ans) <- paste0("bin_", rownames(levels))
    
    genes <- colnames(levels)
    genes <- genes[genes %in% rownames(df)]
    
    
    df <- t(apply(df, 1, function (x){
        if(var(x) > 0.01){
            return(Mclust(x, G = 2)$z[,2])
        }
        return (rep(0, length(x)))
    }))

    levels <- levels > 0
    
    for(i in rownames(levels)) {
        print(paste0("level ", i))
        ans[,paste0("bin_",i)] <- apply(df, 2, 
            function(x){ 
               MCC.prob(x, levels[i,])
            })
    }
    
    ans
}
```

## Makes boxplot of MCC values by cluster
```{r}
BoxFeatureByCluster <- function(srt, which) {
  df <- srt@meta.data[, which]
  df[is.infinite(df)] <- max(df[!is.infinite(df)])
  df <- data.frame(df)
  rownames(df) <- rownames(srt@meta.data)
  colors <- gg_color_hue(length(unique(srt@ident)))

  df$cluster <- factor(srt@ident)
  df$color <- colors[df$cluster]
  
  
  colnames(df) <- c("feature", "cluster", "color")
  print(head(df))
  
  ggplot(df, aes(cluster, feature)) + geom_boxplot(fill = colors) + ylab(which)
}
```


## Imputation of genes using LASSO
```{r}
impute.lasso <- function(srt, gene) {
    genes.all <- rownames(srt@data)
    genes.use <- genes.all[genes.all != gene]
    ta <- t(srt@data[genes.use,])
    tb <- srt@data[gene,]
    tryCatch({
        fit <- cv.glmnet(ta, tb)
        nonzero <- sum( predict(fit, ta, type="coefficients") > 0)
        print(paste0(nonzero, " nonzero genes for ", gene))
        predict(fit, ta, type = "response", s = fit$lambda.min)
    }, error = function(err) { print(err); return(tb)} )
}
```

## Fills the @imputed slot on the seurat object
```{r}
ImputeMarkers <- function(srt, markers) {
    # ImpÃºte with CV Lasso
    srt@imputed <- data.frame(sapply(as.character(markers), function(x) {impute.lasso(srt, x)}))
    
    # Converts to 2 mixture model
    # srt@imputed <- data.frame(apply(srt@imputed, 2, function(x) {
    #    Mclust(x, G = 2)$classification
    #}))
    
    rownames(srt@imputed) <- colnames(srt@data)
    colnames(srt@imputed) <- markers
    srt
}

```

## Calculates MCC
```{r}
MCC <- function(truth, sample) {
    tp <- sum(truth & sample)
    fp <- sum(truth & !sample)
    fn <- sum(!truth & sample)
    tn <- sum(!truth & !sample)
    den <- sqrt((tp+fp)*(tp+fn)*(tn+fp)*(tn+fn))
    if(den == 0) {
        return (0)
    }
    ans <- (tp*tn - fp*fn)/den

    ans
}
```

## Probabilistic MCC
```{r}
MCC.prob <- function(sample, truth) {
    prob.on <- sample
    prob.off <- 1 - sample
    tp <- sum(prob.on[truth])
    tn <- sum(prob.off[!truth])
    fp <- sum(prob.on[!truth])
    fn <- sum(prob.off[truth])
    
    den <- sqrt((tp+fp)*(tp+fn)*(tn+fp)*(tn+fn))
    if(den == 0) {
        return (0)
    }
    ans <- (tp*tn - fp*fn)/den

    ans
}
```


## Null model construction: Permutate dataset
```{r}
permutate.markers <- function(srt, markers, n.times = 50) {
    df <- t(srt@imputed)
    ans <- NULL
    for(i in 1:n.times) {
        print(i)
        ans <- cbind(ans, t(apply(df, 1, sample)))
    }
    
    ans
}
```

## Cell p-values based on null model
```{r}
pval.null <- function(df, null.model) {
    ecdfs <- list()
    for(i in 1:ncol(null.model)) {
      ecdfs[[i]] <- ecdf(null.model[,i])
    }
    
    apply(df, 1, function(x) {
        ans <- rep(0, ncol(null.model))
        for(i in 1:ncol(null.model)) {
          ans [i]<- 1 - ecdfs[[i]](x[i]) 
        }
        ans
    })
}
```


```{r}
SelectPositiveCells <- function(srt, pvals, fdr = .1) {
    ans <- matrix(NA, nrow = nrow(pvals), ncol = ncol(srt@data))
    colnames(ans) <- colnames(srt@data)
    rownames(ans) <- rownames(pvals)
    
    for(i in 1:nrow(pvals)) {
        fs <- 1:ncol(ans)*fdr/ncol(ans)
        ps <- sort(pvals[i,])
        select <- (ps <= fs)
        names(select) <- names(ps)
        ans[i,] <- select[colnames(ans)]
    }
    
    ans
}
```

## Runs spatial reconstruction on seurat object
```{r}
DoSpatialReconstruction <- function(srt, levels, 
                                    num.shuffle = 100, fdr = .1, 
                                    q = 0, do.overwrite = F,
                                    mcc.null = NULL) {
    genes <- colnames(levels)
    
    if(is.null(mcc.null)) {
        write("permutating data", stderr())
        df.null <- permutate.markers(srt, colnames(levels), num.shuffle)
        write("Calculating MCCs for null", stderr())
        mcc.null <- mcc.bin.scores(df.null, levels, q = q)
    }
    
    write("Calculating MCCs for data", stderr())
    mcc.df <-  mcc.bin.scores(srt@data[genes,], levels, q = q)
    
    write("Finding p values", stderr())
    pvals <- pval.null(mcc.df, mcc.null)
    
    write(paste0("Selecting positive cells with fdr ", fdr), stderr())
    cells.select <- SelectPositiveCells(srt, pvals, fdr)
        
    if(do.overwrite) {
        for(i in 1:nrow(levels)) {
            srt <- AddMetaData(srt, -log(pvals[i,]), paste0("logp_",i))
        }
        
        for(i in 1:nrow(levels)) {
            srt <- AddMetaData(srt, cells.select[i,], paste0("keep_",i,"_fdr_",fdr))
        }
        return(srt)
    }
    
    return(sum(colSums(cells.select)>0))
}
```

# Helper functions to handle manipulating nifti data

## Reads nifti stacks into list
```{r}
ReadStacks <- function(inp.dir) {
  ans <- list()
  for(f in list.files(inp.dir)) {
    ans[[f]] <- readNIfTI(paste0(inp.dir, "/", f))@.Data
  }
  
  ans
}
```


## Makes a table off of a list of 3D matrices
```{r}
MakeTableFromImages <- function(imgs) {
  if(length(imgs) == 0) {
    stop("Image list empty")
  }
  
  dims <- dim(imgs[[names(imgs)[1]]])
  ans <- matrix(NA, nrow = prod(dims), ncol = length(imgs))
  colnames(ans) <- names(imgs)
  rn <- c()
  cnt <- 0
  z <- 1
#  for(z in 1:dims[3]){
    for(y in 1:dims[2]) {
      for(x in 1:dims[1]) {
        for(gene in names(imgs)) {
          ans[cnt, gene] <- imgs[[gene]][x,y]
        }
        rn <- c(rn, paste0("x_",x,"_y_",y,"_z_",z))
        cnt <- cnt+1
      }
    }
#  }
  rownames(ans) <- rn
  
  ans
}
```

## Reconstructs the image from a vector with xyz coords as rownames
```{r}
MakeImageFromVector <- function(vec) {
  dims <- as.integer(strsplit(names(tail(vec,1)), "_")[[1]][c(2,4,6)])
  ans <- matrix(NA, nrow = dims[1], ncol = dims[2])

  for(i in 1:dims[1]) {
    for(j in 1:dims[2]) {
      ans[i,j] <- vec[paste0("x_", i, "_y_", j, "_z_1")]
    }
  }
  
  ans
}
```

# Quantile Normalization

## My quantile normalization implementaiton
```{r}
quant.norm <- function(df) {
  df.ranks <- apply(ttt, 2, function(x) { rank(x, ties.method = "min")})
  quantiles <- rowMeans(apply(df, 2, sort))
  
  ans <- matrix(quantiles[df.ranks], nrow = nrow(df))
  rownames(ans) <- rownames(df)
  colnames(ans) <- colnames(df)
  
  ans
}
```
