# Cluster Matching

## Find mutual nearest neighbor cells
```{r}
FindMNN <- function(srt, batch.a = "Human", batch.b = "Organoid") {
  df <- srt@dr$pca@cell.embeddings
  batch <- srt@meta.data$batch
  
  df.a <- df[batch == batch.a, ]
  df.b <- df[batch == batch.b, ]
  
  print(dim(df.a))
  print(dim(df.b))
  
  # Finds B NN for all cells in batch A
  nn.a <- apply(df.a , 1, function(x) {
    which.min(apply(df.b, 1, function(y) {
      sum(y - x)^2
    }))
  })
  
  print(head(nn.a,100))
  
  # Finds A NN in all cells in batch B
  nn.b <- apply(df.b , 1, function(x) {
    which.min(apply(df.a, 1, function(y) {
      sum(y - x)^2
    }))
  })
  
  print(head(nn.b,100))
  ans <- NULL
  
  # Appends to answer all mutual nearest neighbors
  for(i in 1:length(nn.a)) {
    if(nn.b[nn.a[i]] == i) {
      print(paste0("NN of ", i, " is ", nn.a[i]))
      ans <- rbind(ans, df.a[i,] - df.b[nn.a[i], ])
    }
  }
  
  ans
}
```


# Finds pairwise differences between cells of clusters
```{r}
FindPairwise <- function(srt, cl.a = "Human_19", cl.b = "Organoid_9") {
  df <- srt@dr$pca@cell.embeddings
  df.a <- df[srt@ident %in% cl.a, ]
  df.b <- df[srt@ident %in% cl.b, ]
  print(dim(df.a))
  print(dim(df.b))
  
  ans <- NULL
  for(i in 1:nrow(df.a)) {
    for(j in 1:nrow(df.b)) {
      ans <- rbind(ans, df.a[i,] - df.b[j,])
    }
  }
  ans
}
```


## Calculates Sampling Probabilities Using Monte Carlo
```{r}
CalcProbMatrix <- function(srt, groups.a, groups.b, PCs = 1:5, do.fast = T, ...) {
  means.a <- list()
  means.b <- list()
  vars.a <- list()
  vars.b <- list()
  
  for(i in groups.a) {
    res <- Mclust(srt@dr$pca@cell.embeddings[srt@ident == i, PCs], G = 1)
    means.a[[i]] <- res$parameters$mean
    vars.a[[i]] <- res$parameters$variance$Sigma
  }
  
  for(i in groups.b) {
    res <- Mclust(srt@dr$pca@cell.embeddings[srt@ident == i, PCs], G = 1)
    means.b[[i]] <- res$parameters$mean
    vars.b[[i]] <- res$parameters$variance$Sigma
  }
  
  grid.min <- apply(srt@dr$pca@cell.embeddings[,PCs], 2, min)
  grid.max <- apply(srt@dr$pca@cell.embeddings[,PCs], 2, max)
  
  
  ans <- NULL
  props <- summary(droplevels(srt@ident[as.character(srt@ident) %in% as.character(groups.b)]))
  props <- props/sum(props)
  props <- props[groups.b]
  for(i in 1:length(means.a)) {
    write(paste0("Calculating probs for cluster ", groups.a[i]), stderr())
    
    if(do.fast) {
      v <- CalcClassProbsFast(mean = means.a[[i]],
                                     var = vars.a[[i]],
                                     means = means.b,
                                     vars = vars.b,
                                     props = props, ...
                              )
    } else {
      v <- CalcClassProbs(mean = means.a[[i]],
                                     var = vars.a[[i]],
                                     means = means.b,
                                     vars = vars.b,
                                     props = props,
                                     min = grid.min,
                                     max = grid.max
                                     )
    }
    ans <- rbind(ans, v)
  }
  
  rownames(ans) <- groups.a
  colnames(ans) <- groups.b
  ans
}

CalcClassProbs <- function(mean = c(3,3,3), 
                           var = matrix(c(1,.5,.5,.5,1,.5,.5,.5,1),nrow=3), 
                           means = list(m1 = c(1,2,2), m2 = c(4,5,5)),
                           vars = list(v1 = matrix(c(1,0,0,0,1,0,0,0,1),nrow=3), 
                                        v2 = matrix(c(1,0,0,0,1,0,0,0,1),nrow=3)
                                        ),
                           props = c(.5, .5), 
                           min = c(-10,-10,-10), 
                           max = c(10,10,10)) {

  ans <- rep(0, length(means))
  
  for(j in 1:length(means)) {
    ans[j] <- divonne(ndim = length(mean), ncomp = 1, lower = min, upper = max, 
        integrand = function(x, ...) {
          ans <- 0
          sum <- 0
          for(k in 1:length(means)) {
            sum <- sum + props[k]*dmvnorm(x, means[[k]], vars[[k]])
          }
          
          props[j]*dmvnorm(x, means[[j]], vars[[j]])*dmvnorm(x,mean, var)/sum
    })$value
  }
  
  ans
  
}

# Simple sampling to calculate probabilities
CalcClassProbsFast <- function(mean = c(3,3,3), 
                           var = matrix(c(1,.5,.5,.5,1,.5,.5,.5,1),nrow=3), 
                           means = list(m1 = c(1,2,2), m2 = c(4,5,5)),
                           vars = list(v1 = matrix(c(1,0,0,0,1,0,0,0,1),nrow=3), 
                                        v2 = matrix(c(1,0,0,0,1,0,0,0,1),nrow=3)
                                        ),
                           props = c(.5, .5), npoints=10000) {
  
  points <- rmvnorm(npoints, mean, var)
  ans <- apply(apply(points, 1, function(x) {
    aux <- rep(0, length(means))
    for(i in 1:length(means)) {
      aux[i] <- dmvnorm(x, means[[i]], vars[[i]])
    }
    aux*props/sum(aux*props)
  }), 1, mean)
  
  print(ans)
  ans
}
```

## More decent pheatmap to show matching
```{r}
phm <- function(tbl) {
  pheatmap(tbl, cluster_rows = F, cluster_cols = T, display_numbers = T, number_format = "%.2f",
           color = colorRampPalette(c("darkblue","red"))(30), number_color = "#FFFFFF")
}
```

## Finds matching between clusters based on probs > uniform
```{r}
FindMatching <- function(match.ab, match.ba) {
  unif.ab <- t(apply(match.ab, 1, function(x) {x > 1/length(x)}))
  unif.ba <- t(apply(match.ba, 1, function(x) {x > 1/length(x)}))
  
  ans <- NULL
  for(i in rownames(unif.ab)) {
    for(j in rownames(unif.ba)) {
      if(unif.ab[i,j]  & unif.ba[j,i]) {
        ans <- rbind(ans, data.frame(x = i, y = j))
      }
    }
  }
  ans
}
```

## Plots matching with igraph
```{r}
PlotMatching <- function(matching) {
  g <- graph.data.frame(matching, directed = F)
  V(g)$type <- V(g)$name %in% matching[,1]
  
  plot(g, layout = layout_as_bipartite)
}
```


