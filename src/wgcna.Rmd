#################################################################################################
# WGCNA
#################################################################################################

## Transpose seurat data into WGCNA object
```{r}
# Puts scaled data in WGCNA format
GetDatExpr <- function(srt, markers) {
  genes.use <- unique(markers$gene)
  t(srt@scale.data[genes.use,])
}
```

## Pick power threshold of correlation
```{r}
# Picks soft threshold power
getSft <- function(datExpr, plot=F) {
  powers <- c(1:10, 2*6:10)
  sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
  
  if(plot){
    par(mfrow = c(1,2))
    cex1 = 0.9;
    
    plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
         xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
         main = paste("Scale independence"));
    text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
         labels=powers,cex=cex1,col="red");
    
    abline(h=0.90,col="red")
    
    plot(sft$fitIndices[,1], sft$fitIndices[,5],
         xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
         main = paste("Mean connectivity"))
    text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
  }
  return(sft)
}
```

## Finds modules of signed network (NEVER USE UNSIGNED FOR SINGLE CELL!!)
```{r}
# Finds modules from raw expression
Modules <- function(datExpr, p) {
  blockwiseModules(datExpr, power = p, TOMType="unsigned", 
                   minModuleSize = 10, deepSplit = 3, pamRespectsDendro = F,  
                   numericLabels = F, minKMEtoStay = 0, saveTOMs = F, verbose = 5)
}
```

## Plots gene dendrogram and module colors
```{r}
# Plots Cluster Dendrogram
PlotNet <- function(net) {
  plotDendroAndColors(net$dendrograms[[1]], net$unmergedColors[net$blocks == 1], dendroLabels = F, "Module colors")
}
```

## Gene heatmaps of specific modules
```{r}
# Heatmap of a specific module
PlotModule <- function(srt, datExpr, net, which) {
  genes <- colnames(datExpr)[net$colors == which]
  if(length(genes) > 200){
    genes <- genes[1:200]
  }
  DoHeatmap(srt, genes.use = genes, order.by.ident = TRUE, slim.col.label = TRUE, remove.key = TRUE, draw.line = T)
}
```

## Prints top genes (based on connectivity) for a given module
```{r}
GetGenesFromModule <- function(datExpr, power, net, which) {
  datExpr <- datExpr[,net$colors == which]
  adj <- adjacency(datExpr, power = power)
  adj <- rowSums(adj)
  
  colnames(datExpr)[order(-adj)]
}
```

## Draws module network using igraph
```{r}
PlotModuleNetwork <- function (datExpr, power, net, which, thresh = .01) {
  dat <- datExpr[, net$colors == which]
  IMConn <- softConnectivity(dat)
  ntop <- min(150, sum(net$colors == which))
  top <- rank(-IMConn) <= ntop

  adj <- adjacency(dat[,top], power = power)
  adj[adj <= thresh] <- 0
  adj[adj >= thresh] <- 1
  diag(adj) <- 0

  gg <- simplify(graph_from_adjacency_matrix(adj, mode="undirected"))
  gg <- delete.vertices(gg, which(degree(gg) == 0)) 
  plot(gg, vertex.size = 4, vertex.label.cex = .8, vertex.label.dist = .3, 
       vertex.color="red", vertex.frame.color="black")
}
```


## Calculates Module Score for all cells
```{r}
ModuleScore <- function(datExpr, power, net, mon) {
    ans <- net$MEs
    rownames(ans) <- rownames(datExpr)
    
    ans$Pseudotime <- mon@phenoData@data[rownames(ans),]$Pseudotime
    ans
}
```

## Plots scores
```{r}
PlotScores <- function(scores, net) {
  X11(width = 16, height = 9)
  plot(NA, xlab = "Pseudotime", ylab="Module score", 
       xlim = c(0, max(scores$Pseudotime)), ylim = c(min(scores[, !(colnames(scores) %in% "Pseudotime")]), max(scores[,!(colnames(scores) %in% "Pseudotime")])))
  
  colors <- c()
  for(i in unique(net$colors)) {
    if(i != "grey"){
        if(sum(net$colors == i)>10) {
          print(i)
          lines(smooth.spline(scores$Pseudotime, scores[,paste0("ME",i)], spar = 0.7), col = i)
          colors <- c(colors, i) 
        }
      }
  }
  legend("topleft", col = colors, legend = colors, lwd=.5, ncol = floor(length(colors)/3), cex = .75,lty=1)
}

```

## ME boxplot
```{r}
BoxMEByCluster <- function(srt, datExpr, net, which) {
  df <- data.frame(net$MEs[,paste0("ME",which)])
  rownames(df) <- rownames(datExpr)
  colors <- gg_color_hue(length(unique(srt@ident)))

  df$cluster <- factor(srt@data.info[rownames(df),]$tree.ident)
  df$color <- colors[df$cluster]
  
  print(head(df))
  
  colnames(df) <- c("module", "cluster", "color")
  
  ggplot(df, aes(cluster, module)) + geom_boxplot(fill = colors)
}
```

## Uses a 2 mixture model to find cells that are + and - for some module
```{r}
SelectMECells <- function(datExpr, net, which) {
  MEs <- net$MEs[, paste0("ME", which)]
  mm <- Mclust(MEs, G = 2)
  
  positive.clust <- which(mm$parameters$mean == max(mm$parameters$mean))
  negative.clust <- which(mm$parameters$mean == min(mm$parameters$mean))
  
  ans <- mm$z[,positive.clust]
  names(ans) <- rownames(datExpr)
  
  ans
}
```

## Returns a data frame that gives +- of every module for all single cells
```{r}
ModuleDF <- function(datExpr, net, p.cutoff = 1e-3) {
  ans <- NULL
  for(i in unique(net$colors)) {
    ans <- cbind(ans, SelectMECells(datExpr, net, i, p.cutoff))
  }
  
  colnames(ans) <- unique(net$colors)
  ans
}
```
