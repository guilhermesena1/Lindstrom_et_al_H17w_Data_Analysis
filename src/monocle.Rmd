
#################################################################################################
# MONOCLE
#################################################################################################

## Converts Seurat Object into Monocle Object and Run Monocle Pipeline
```{r}
# Creates Monocle object from Seurat data
monocle.from.seurat <- function(srt, diffexp){
  cerr("Building Monocle Object...")
  mon <- importCDS(srt, import_all = T)
  mon@phenoData@data$ident <- srt@ident
  
  cerr("Normalizing...")
  mon <- setOrderingFilter(mon, unique(diffexp$gene))
  mon <- estimateSizeFactors(mon)
  mon <- estimateDispersions(mon)

cerr("Running ICA...")
  mon <- reduceDimension(mon, max_components = 2)
  
  mon <- orderCells(mon)
  mon
}
```

## Filters differential gene test by n cells cutoff and q val cutoff
```{r}
do.dgt <- function(srt, mon) {
  genes.use <- srt@var.genes[srt@var.genes %in% rownames(mon@assayData$exprs)]
  differentialGeneTest(mon[genes.use,], relative_expr = F)
}
dgt.filter <- function(dgt, qval.cutoff = 1, ncells.cutoff = 0) {
  dgt <- dgt[dgt$qval < qval.cutoff, ]
  dgt <- dgt[dgt$num_cells_expressed > ncells.cutoff, ]
  dgt <- dgt[order(dgt$qval),]
  
  dgt
}
```

## Subpath analysis: Selects only a subset of states from a monocle object
```{r}
mon.sub <- function(mon, states) {
    cerr("Subsetting...")
    cells.keep <- rownames(mon@phenoData@data)[mon@phenoData@data$State %in% states]

    ret <- mon[, cells.keep]
    cerr("Doing ICA...")
    ret <- reduceDimension(ret, max_components = 2)
    cerr("Ordering...")
    ret <- orderCells(ret)
    ret
}
```

## Plots expression heatmap for top genes using pheatmap
```{r}
monocle.heatmap <- function(srt, mon, diff) {
  # gets cells in order
  cells.by.pseudotime <- colnames(srt@data)[colnames(srt@data) %in% colnames(mon@assayData$exprs)]
  cells.by.pseudotime <- cells.by.pseudotime[order(mon@phenoData@data[cells.by.pseudotime,"Pseudotime"])]
  genes.top <- rownames(diff)
  anno <- data.frame(Pseudotime = mon@phenoData@data[cells.by.pseudotime, "Pseudotime"])
  rownames(anno) <- cells.by.pseudotime
  
  pheatmap(as.matrix(srt@data[genes.top, cells.by.pseudotime]), 
           cluster_cols = F, cluster_rows = T, 
           show_colnames = F, show_rownames = T, 
           annotation = anno)
}
```

## Plots and saves pseudotime heatmaps
```{r}
PseudotimeFeatureAll <- function(mon, srt, genes, out.dir) {
  for(i in genes) {
    print(plot_cell_trajectory(mon, srt, gene = i))
    dev.print(pdf, file = sprintf(paste0(out.dir,"/%s.pdf"), i), width = 16, height = 9)
  }
}
```

## Plots and saves Monocle genes
```{r}
GeneAll <- function(mon, genes, out.dir) {
  for(i in genes) {
    print(plot_genes_in_pseudotime(mon[i,], relative_expr = F, color_by="tree.ident"))
    dev.print(pdf, file = sprintf(paste0(out.dir, "/%s.pdf"), i))
  }
}

```

## Gets MST in ICA space
```{r}
get_df_edge <- function(cds, x, y) {
    gene_short_name <- NA
    sample_name <- NA
    data_dim_1 <- NA
    data_dim_2 <- NA
    lib_info_with_pseudo <- pData(cds)
    if (is.null(cds@dim_reduce_type)) {
        stop("Error: dimensionality not yet reduced. Please call reduceDimension() before calling this function.")
    }
    
    # Gets DDRTree low dimension coords
    reduced_dim_coords <- reducedDimK(cds)
    
    # Reduces DDR coordinates to ICA
    ica_space_df <- data.frame(Matrix::t(reduced_dim_coords[c(x, 
        y), ]))
    colnames(ica_space_df) <- c("prin_graph_dim_1", "prin_graph_dim_2")
    ica_space_df$sample_name <- row.names(ica_space_df)
    dp_mst <- minSpanningTree(cds)
    
    edge_list <- as.data.frame(get.edgelist(dp_mst))
    colnames(edge_list) <- c("source", "target")
    edge_df <- merge(ica_space_df, edge_list, by.x = "sample_name", 
        by.y = "source", all = TRUE)
    edge_df <- plyr::rename(edge_df, c(prin_graph_dim_1 = "source_prin_graph_dim_1", 
        prin_graph_dim_2 = "source_prin_graph_dim_2"))
    edge_df <- merge(edge_df, ica_space_df[, c("sample_name", 
        "prin_graph_dim_1", "prin_graph_dim_2")], by.x = "target", 
        by.y = "sample_name", all = TRUE)
    edge_df <- plyr::rename(edge_df, c(prin_graph_dim_1 = "target_prin_graph_dim_1", 
        prin_graph_dim_2 = "target_prin_graph_dim_2"))
    S_matrix <- reducedDimS(cds)
    data_df <- data.frame(t(S_matrix[c(x, y), ]))
    colnames(data_df) <- c("data_dim_1", "data_dim_2")
    data_df$sample_name <- row.names(data_df)
    data_df <- merge(data_df, lib_info_with_pseudo, by.x = "sample_name", 
        by.y = "row.names")

    tmp <- t(as.matrix(data_df[, c(2, 3)]))
    data_df$data_dim_1 <- tmp[1, ]
    data_df$data_dim_2 <- tmp[2, ]
    tmp <- t(as.matrix(edge_df[, c("source_prin_graph_dim_1", "source_prin_graph_dim_2")]))
    edge_df$source_prin_graph_dim_1 <- tmp[1, ]
    edge_df$source_prin_graph_dim_2 <- tmp[2, ]
    tmp <- t(as.matrix(edge_df[, c("target_prin_graph_dim_1", "target_prin_graph_dim_2")]))
    edge_df$target_prin_graph_dim_1 <- tmp[1, ]
    edge_df$target_prin_graph_dim_2 <- tmp[2, ]
    
    list(data_df = data_df, edge_df = edge_df)
}
```

## Plots cell trajectory
```{r}
plot_cell_trajectory <- function (cds, srt = NULL, x = 1, y = 2, color_by = "tree.ident", gene = NULL, clust.ref = NULL) {
    
    # Gets branching points
    stuff <- get_df_edge(cds,x,y)
    data_df <- stuff[["data_df"]]
    edge_df <- stuff[["edge_df"]]
    
    # set colors for points
    if(is.null(gene)) {
      if(is.null(clust.ref)) {
          clust.ref <- unique(cds@phenoData@data[,color_by])
      }
        
      hack <- 1:length(clust.ref)
      names(hack) <- sort(clust.ref)
      cols <- gg_color_hue(length(clust.ref))
      colors.gg <- cols[data_df[,color_by]]
        
    } else {
        
      data_df[,gene] <- srt@data[gene, data_df$sample_name]
    }
    
    print(head(data_df[,color_by]))
    
    ### PLOT STARTS HERE
    g <- ggplot(data = data_df, aes_string(x = "data_dim_1", y = "data_dim_2"))
    
    # Tree backbone
    g <- g + geom_segment(colour="grey", aes_string(x = "source_prin_graph_dim_1", 
            y = "source_prin_graph_dim_2", xend = "target_prin_graph_dim_1", 
            yend = "target_prin_graph_dim_2"), size = 0.75, 
            linetype = "solid", na.rm = TRUE, data = edge_df) 
            
    # single cells if colored by metadata
    if(is.null(gene) & !is.null(color_by)) { 
      g <- g + geom_point(colour = colors.gg)
    } else {
      g <- g + geom_point(aes_string(color = gene), size = 1.5, 
            na.rm = TRUE) + scale_colour_gradient(low = "darkblue", high = "red")
    }
    
    
    # Gets branching points
    mst_branch_nodes <- cds@auxOrderingData[[cds@dim_reduce_type]]$branch_points
    branch_point_df <- subset(edge_df, sample_name %in% mst_branch_nodes)[,
        c("sample_name", "source_prin_graph_dim_1", "source_prin_graph_dim_2")]
    branch_point_df$branch_point_idx <- match(branch_point_df$sample_name,
        mst_branch_nodes)
    branch_point_df <- branch_point_df[!duplicated(branch_point_df$branch_point_idx),
        ]

    # Plots branching points
    g <- g + geom_point(aes_string(x = "source_prin_graph_dim_1",
        y = "source_prin_graph_dim_2"), size = 5, na.rm = TRUE,
        data = branch_point_df) +
        geom_text(aes_string(x = "source_prin_graph_dim_1",
        y = "source_prin_graph_dim_2", label = "branch_point_idx"),
        size = 4, color = "white", na.rm = TRUE, data = branch_point_df) +


    # Theme
    theme(axis.line=element_blank(),
      axis.text.x=element_blank(),
      axis.text.y=element_blank(),
      axis.ticks=element_blank(),
      axis.title.x=element_blank(),
      axis.title.y=element_blank(),
      legend.position = "right"
      )

    g
}
```

